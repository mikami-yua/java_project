多线程
    1.什么是进程，什么是线程
        进程：是一个应用程序
        线程：一个进程中的执行场景/执行单元
        一个进程可以启动多个线程

    2.对于java程序来说，当在DOS窗口中输入：
        java HelloWorld 回车之后
        会先启动jvm，而jvm就是一个进程
        jvm再启动一个主线程调用main方法。
        同时再启动一个垃圾回收线程负责看护，回收垃圾。
        最起码，现在的java程序中至少两个线程并发
        一个是垃圾回收线程，一个是执行main方法的主线程

    3.进程和线程之间的关系
        进程可以看作是公司
        线程可以看作公司的员工

        【注意】：
            进程A和进程B的内存独立不共享。
            Java中线程A和线程B堆内存和方法区内存共享，但是栈内存独立，一个线程一个栈

        多线程机制主要是为了提高程序的处理效率

        线程相当于进程的一个执行单元

        方法区和堆都只有一块，线程共享
        栈有多个，一个线程一个。
        main方法调用了m1和m2方法，则m1和m2都再主线程中。
        main方法结束只代表主线程结束



    4.思考：
        是否main方法结束，程序也可能不结束。------是
                    main方法结束只是，主栈空了，其他栈可能还在压栈，弹栈

        分析：对于单核的cpu来说真的可以做到真正的多线程并发？
                    多线程并发：
                        t1线程执行t1的
                        t2线程执行t2的
                        两个线程不会互相影响。
                    单核cpu不能做到真正的多线程并发，但是可以做到给人多线程的感觉。单核的cpu在某个时间点上实际上只能处理1件事，但是因为cpu
                    的处理速度极快，多个线程之间频繁切换，给人的感觉是多个事情共同执行


                    对于多核电脑，真正的多线程是可以做到的
                        4核cpu，表示再同一个时间点上，可以真正有4个进程并发执行。


    5.Java中实现线程的两种方式
        方法1：编写一个类直接继承java.lang.Thread重写run方法

        方法2：编写一个类，实现java.lang.Runnable接口实现run方法

        方法1继承了thread就不能再继承别的类了。一个类实现了接口还可以继承别的类，更灵活


    6.线程的生命周期
        1·刚new出来的线程对象处于：新建状态
        2·调用了start（）方法处于：就绪状态
            就绪状态又称为可执行状态，表示处于当前状态的线程具有抢夺cpu时间片的权力（cpu时间片就是执行权）
        3·当一个线程抢夺到cpu时间片之后就处于：运行状态
            开始执行run方法。run方法的开始运行标志着这个线程进入了运行状态
        4.之前占有的cpu时间片用完之后，回重新回到就绪状态，继续抢夺cpu时间片
        5.再次抢夺到cpu时间片之后，会重新进入run方法接着上次的代码继续往下执行
        【ps】就绪状态&运行状态的频繁切换需要jvm的调度
        5.当run方法执行结束就处于：死亡状态

        线程在就绪状态和运行状态中频繁变化

        6.线程运行过程中，出现一个接受用户输入的代码等阻塞事件，会进入阻塞状态。
            当一个线程遇到阻塞事件，如接受用户输入&sleep（）方法等。此时线程会进入阻塞状态，阻塞状态的线程会放弃当前占用的cpu时间片
        7.当阻塞解除会进入就绪状态，抢夺cpu时间片
        8.当线程遇到了synchronized关键字，会放弃当前占有的cpu时间片，到锁池（lockpool）中找共享对象的对象锁，没找到就会在锁池中等
            着，一旦找到就进入就绪状态。继续抢夺cpu时间片（进入锁池可以理解为一种阻塞状态）



    7.关于线程的调度：
        常见的线程调度模型：
            抢占式调度模型
                那个线程的优先级比较高，抢到的cpu时间片的概率就高一些
                Java采用的就是抢占式调度模型

            均分式调度模型
                平均分配cpu时间片。

        java中提供了和线程调度有关的方法
            void setPriority(int newPriority)   设置线程优先级     实例方法
            void getPriority()                  获取线程优先级
            最低优先级是  1
            默认。。。。。5
            最高。。。。。10

            static void yield()                 让位方法            静态方法
                暂停当前正在执行的线程，并执行其他进程
                yield()不是阻塞，会是当前线程从运行状态回到就绪状态
                让一下有可能再抢到

            void join()                                实例方法
            合并线程
                class MyThread1 extends Thread{
                    public void doSome(){
                        MyThread2 t= new MyThread2():
                        t.join();//当前线程阻塞，t线程执行，直到t线程结束。当前线程才可以继续执行
                    }
                }

                class MyThread2 extends Thread{

                }


    【重点】
    8.多线程并发环境下，数据的安全问题
        重点：以后开发中，项目是运行在服务器上的。服务器已经完成了线程的定义，创建，启动。这些代码都不需要编写
        【重点*****】
        最重要的是：明白编写的程序以后需要放到一个多线程的环境下运行，开发者更需要关注这些数据在多线程并发的环境下是否安全。

        数据在多线程的环境下会存在不安全的问题，三个条件
            1.多线程并发
            2.有共享数据
            3.共享数据有修改行为

        解决方案：
            满足3个条件时，线程排队执行。
            用线程排队执行解决线程的安全问题。这种机制叫做线程同步机制

            专业术语线程同步======白话线程排队

            线程同步会牺牲一部分效率，但满足了安全的要求

        线程同步设计到的术语【异步就是并发，同步就是排队】
            1.同步编程模型
                线程t1和线程t2，在t1执行的时候必须等t2执行结束。两个线程之间发生了等待关系
                （线程排队执行------效率低）
            2.异步编程模型
                线程t1和线程t2.各自执行各自的，谁也不需要等谁
                （其实就是多线程并发------效率高）


    9.java中的三大变量
        实例变量：堆中

        静态变量：方法区中

        局部变量：栈中
            永远不会有线程安全问题，一个线程一个栈

        堆和方法区都只有1个，可能存在线程安全问题

        常量也不会有线程安全问题（常量不可修改）

        如果使用局部变量的话，建议使用StringBuilder。虽然StringBuffer是线程安全的。但是局部变量不需要考虑线程安全问题
        ArrayList是非线程安全的
        Vector是线程安全的
        HashMap HashSet是非线程安全的
        HashTable是线程安全的