多线程
    1.什么是进程，什么是线程
        进程：是一个应用程序
        线程：一个进程中的执行场景/执行单元
        一个进程可以启动多个线程

    2.对于java程序来说，当在DOS窗口中输入：
        java HelloWorld 回车之后
        会先启动jvm，而jvm就是一个进程
        jvm再启动一个主线程调用main方法。
        同时再启动一个垃圾回收线程负责看护，回收垃圾。
        最起码，现在的java程序中至少两个线程并发
        一个是垃圾回收线程，一个是执行main方法的主线程

    3.进程和线程之间的关系
        进程可以看作是公司
        线程可以看作公司的员工

        【注意】：
            进程A和进程B的内存独立不共享。
            Java中线程A和线程B堆内存和方法区内存共享，但是栈内存独立，一个线程一个栈

        多线程机制主要是为了提高程序的处理效率

        线程相当于进程的一个执行单元

        方法区和堆都只有一块，线程共享
        栈有多个，一个线程一个。
        main方法调用了m1和m2方法，则m1和m2都再主线程中。
        main方法结束只代表主线程结束



    4.思考：
        是否main方法结束，程序也可能不结束。------是
                    main方法结束只是，主栈空了，其他栈可能还在压栈，弹栈

        分析：对于单核的cpu来说真的可以做到真正的多线程并发？
                    多线程并发：
                        t1线程执行t1的
                        t2线程执行t2的
                        两个线程不会互相影响。
                    单核cpu不能做到真正的多线程并发，但是可以做到给人多线程的感觉。单核的cpu在某个时间点上实际上只能处理1件事，但是因为cpu
                    的处理速度极快，多个线程之间频繁切换，给人的感觉是多个事情共同执行


                    对于多核电脑，真正的多线程是可以做到的
                        4核cpu，表示再同一个时间点上，可以真正有4个进程并发执行。


    5.Java中实现线程的两种方式
        方法1：编写一个类直接继承java.lang.Thread重写run方法

        方法2：编写一个类，实现java.lang.Runnable接口实现run方法

        方法1继承了thread就不能再继承别的类了。一个类实现了接口还可以继承别的类，更灵活


    6.线程的生命周期
        1·刚new出来的线程对象处于：新建状态
        2·调用了start（）方法处于：就绪状态
            就绪状态又称为可执行状态，表示处于当前状态的线程具有抢夺cpu时间片的权力（cpu时间片就是执行权）
        3·当一个线程抢夺到cpu时间片之后就处于：运行状态
            开始执行run方法。run方法的开始运行标志着这个线程进入了运行状态
        4.之前占有的cpu时间片用完之后，回重新回到就绪状态，继续抢夺cpu时间片
        5.再次抢夺到cpu时间片之后，会重新进入run方法接着上次的代码继续往下执行
        【ps】就绪状态&运行状态的频繁切换需要jvm的调度
        5.当run方法执行结束就处于：死亡状态

        线程在就绪状态和运行状态中频繁变化

        6.线程运行过程中，出现一个接受用户输入的代码等阻塞事件，会进入阻塞状态。
            当一个线程遇到阻塞事件，如接受用户输入&sleep（）方法等。此时线程会进入阻塞状态，阻塞状态的线程会放弃当前占用的cpu时间片
        7.当阻塞解除会进入就绪状态，抢夺cpu时间片
        8.当线程遇到了synchronized关键字，会放弃当前占有的cpu时间片，到锁池（lockpool）中找共享对象的对象锁，没找到就会在锁池中等
            着，一旦找到就进入就绪状态。继续抢夺cpu时间片（进入锁池可以理解为一种阻塞状态）



    7.关于线程的调度：
        常见的线程调度模型：
            抢占式调度模型
                那个线程的优先级比较高，抢到的cpu时间片的概率就高一些
                Java采用的就是抢占式调度模型

            均分式调度模型
                平均分配cpu时间片。

        java中提供了和线程调度有关的方法
            void setPriority(int newPriority)   设置线程优先级     实例方法
            void getPriority()                  获取线程优先级
            最低优先级是  1
            默认。。。。。5
            最高。。。。。10

            static void yield()                 让位方法            静态方法
                暂停当前正在执行的线程，并执行其他进程
                yield()不是阻塞，会是当前线程从运行状态回到就绪状态
                让一下有可能再抢到

            void join()                                实例方法
            合并线程
                class MyThread1 extends Thread{
                    public void doSome(){
                        MyThread2 t= new MyThread2():
                        t.join();//当前线程阻塞，t线程执行，直到t线程结束。当前线程才可以继续执行
                    }
                }

                class MyThread2 extends Thread{

                }


    【重点】
    8.多线程并发环境下，数据的安全问题
        重点：以后开发中，项目是运行在服务器上的。服务器已经完成了线程的定义，创建，启动。这些代码都不需要编写
        【重点*****】
        最重要的是：明白编写的程序以后需要放到一个多线程的环境下运行，开发者更需要关注这些数据在多线程并发的环境下是否安全。

        数据在多线程的环境下会存在不安全的问题，三个条件
            1.多线程并发
            2.有共享数据
            3.共享数据有修改行为

        解决方案：
            满足3个条件时，线程排队执行。
            用线程排队执行解决线程的安全问题。这种机制叫做线程同步机制

            专业术语线程同步======白话线程排队

            线程同步会牺牲一部分效率，但满足了安全的要求

        线程同步设计到的术语【异步就是并发，同步就是排队】
            1.同步编程模型
                线程t1和线程t2，在t1执行的时候必须等t2执行结束。两个线程之间发生了等待关系
                （线程排队执行------效率低）
            2.异步编程模型
                线程t1和线程t2.各自执行各自的，谁也不需要等谁
                （其实就是多线程并发------效率高）


    9.java中的三大变量
        实例变量：堆中

        静态变量：方法区中

        局部变量：栈中
            永远不会有线程安全问题，一个线程一个栈

        堆和方法区都只有1个，可能存在线程安全问题

        常量也不会有线程安全问题（常量不可修改）

        如果使用局部变量的话，建议使用StringBuilder。虽然StringBuffer是线程安全的。但是局部变量不需要考虑线程安全问题
        ArrayList是非线程安全的
        Vector是线程安全的
        HashMap HashSet是非线程安全的
        HashTable是线程安全的

    【总结】synchronized有两种写法
        1.同步代码块
            synchronized (this){
                        double before=this.getBalance();
                        //取款后的余额
                        double after=before-money;
                        //在这里模拟网络延迟100%出问题
                        try {
                            Thread.sleep(1000);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        this.setBalance(after);
            }
            灵活
        2.在实例方法上使用synchronized
            表示共享对象一定是this，并且同步代码块是整个方法体
        3.在静态方法上使用synchronized
            表示找类锁，类锁只有1把，就算创建了100个对象，类锁也只有1把
                对象锁，一个对象一把锁，100个对象100把锁

    10.死锁
        程序不出现异常也不出现错误，一直僵持在哪里【最难调的错误】

    11.开发中怎么解决线程安全问题
        不是一上来就synchronized，这会使程序的执行效率降低。用户吞吐量降低，用户体验差。在不得已的情况下，再使用线程同步机制

        方案1：尽量使用局部变量代替实例变量和静态变量

        方案2：如果必须是实例变量，可以考虑创建多个对象，这样实例变量的内存就不共享了。

        方案3：不能使用局部变量，对象也不能创建多个，只能选择synchronized线程同步机制

    12.
        守护线程
            又称为后台线程
            java中线程分两类
                用户线程
                守护线程
            特点：一般是个死循环，所有用户线程结束，守护线程自动结束

            用在的地方：
                垃圾回收器
                固定时间上次日志（将定时器设置为守护线程）

        定时器
            作用：间隔特定的时间执行特定的程序
            ps：每天的数据备份操作
            1.使用sleep定时
            2.java.util.Timer(很少用了)
            3.目前使用较多的使spring框架中提供的springTask框架


        实现线程的第三种方式：FutureTask方式，实现Callable接口（JDK8新特性）
            这种方式实现的线程可以获取线程的返回值-------拿到线程的执行结果
            之前的两种方式没有返回值，run方法是void的

        Object类种的wait和notify方法（生产者和消费者模式）
            1.wait和notify方法不是线程对象的方法，java中任何一个对象都有这个方法。这两个方法是Object类中自带的
            2.wait作用
                Object 0=new Object（）；
                o.wait();
                表示：让正在o对象上活动的线程进入等待状态，直至被唤醒。（调用o.notify()）
            2.notify作用
                调用o.notify()，让o上正在等待的线程被唤醒
                Object o=new Object();
                o.notify();
                表示：
                    唤醒正在o对象上等待的线程

                notifyAll（）方法
                    唤醒在o对象上的所有线程

            生产者和消费者模式：
                目的：为了专门解决某种特定的需求
                一个线程负责生产，一个线程负责消费，最后达到生产和消费均衡。生产满了就不能再生产了，必须让消费线程消费；消费完了就不能
                    再消费了，需要生产者生产。
                仓库是多线程共享的，需要考虑线程安全问题。仓库调用wait和notify方法。
                【重点】wait和notify方法建立在synchronized线程同步的基础上
                【重点】o.wait();会让正在o上活动的当前线程进入等待状态，并且释放之前占有的o对象的锁。o.notify();只会通知，不会释放锁

